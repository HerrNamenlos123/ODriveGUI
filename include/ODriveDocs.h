#pragma once

#include "pch.h"
#include "Endpoint.h"

BETTER_ENUM( AxisError, int32_t,
	AXIS_ERROR_NONE							= 0x00000000,
	AXIS_ERROR_INVALID_STATE				= 0x00000001,
	AXIS_ERROR_DC_BUS_UNDER_VOLTAGE			= 0x00000002,
	AXIS_ERROR_DC_BUS_OVER_VOLTAGE			= 0x00000004,
	AXIS_ERROR_CURRENT_MEASUREMENT_TIMEOUT	= 0x00000008,
	AXIS_ERROR_BRAKE_RESISTOR_DISARMED		= 0x00000010,
	AXIS_ERROR_MOTOR_DISARMED				= 0x00000020,
	AXIS_ERROR_MOTOR_FAILED					= 0x00000040,
	AXIS_ERROR_SENSORLESS_ESTIMATOR_FAILED	= 0x00000080,
	AXIS_ERROR_ENCODER_FAILED				= 0x00000100,
	AXIS_ERROR_CONTROLLER_FAILED			= 0x00000200,
	AXIS_ERROR_POS_CTRL_DURING_SENSORLESS	= 0x00000400,
	AXIS_ERROR_WATCHDOG_TIMER_EXPIRED		= 0x00000800,
	AXIS_ERROR_MIN_ENDSTOP_PRESSED			= 0x00001000,
	AXIS_ERROR_MAX_ENDSTOP_PRESSED			= 0x00002000,
	AXIS_ERROR_ESTOP_REQUESTED				= 0x00004000,
	AXIS_ERROR_HOMING_WITHOUT_ENDSTOP		= 0x00020000,
	AXIS_ERROR_OVER_TEMP					= 0x00040000
)

static std::map<std::string, std::string> AxisErrorDesc = {
	{ "", "" }
};




BETTER_ENUM(MotorError, int32_t,
	MOTOR_ERROR_NONE								= 0x00000000,
	MOTOR_ERROR_PHASE_RESISTANCE_OUT_OF_RANGE		= 0x00000001,
	MOTOR_ERROR_PHASE_INDUCTANCE_OUT_OF_RANGE		= 0x00000002,
	MOTOR_ERROR_ADC_FAILED							= 0x00000004,
	MOTOR_ERROR_DRV_FAULT							= 0x00000008,
	MOTOR_ERROR_CONTROL_DEADLINE_MISSED				= 0x00000010,
	MOTOR_ERROR_NOT_IMPLEMENTED_MOTOR_TYPE			= 0x00000020,
	MOTOR_ERROR_BRAKE_CURRENT_OUT_OF_RANGE			= 0x00000040,
	MOTOR_ERROR_MODULATION_MAGNITUDE				= 0x00000080,
	MOTOR_ERROR_BRAKE_DEADTIME_VIOLATION			= 0x00000100,
	MOTOR_ERROR_UNEXPECTED_TIMER_CALLBACK			= 0x00000200,
	MOTOR_ERROR_CURRENT_SENSE_SATURATION			= 0x00000400,
	MOTOR_ERROR_CURRENT_LIMIT_VIOLATION				= 0x00001000,
	MOTOR_ERROR_BRAKE_DUTY_CYCLE_NAN				= 0x00002000,
	MOTOR_ERROR_DC_BUS_OVER_REGEN_CURRENT			= 0x00004000,
	MOTOR_ERROR_DC_BUS_OVER_CURRENT					= 0x00008000,
	MOTOR_ERROR_MODULATION_IS_NAN					= 0x00010000,
	MOTOR_ERROR_MOTOR_THERMISTOR_OVER_TEMP			= 0x00020000,
	MOTOR_ERROR_FET_THERMISTOR_OVER_TEMP			= 0x00040000,
	MOTOR_ERROR_TIMER_UPDATE_MISSED					= 0x00080000,
	MOTOR_ERROR_CURRENT_MEASUREMENT_UNAVAILABLE		= 0x00100000,
	MOTOR_ERROR_CONTROLLER_FAILED					= 0x00200000,
	MOTOR_ERROR_I_BUS_OUT_OF_RANGE					= 0x00400000,
	MOTOR_ERROR_BRAKE_RESISTOR_DISARMED				= 0x00800000,
	MOTOR_ERROR_SYSTEM_LEVEL						= 0x01000000,
	MOTOR_ERROR_BAD_TIMING							= 0x02000000,
	MOTOR_ERROR_UNKNOWN_PHASE_ESTIMATE				= 0x04000000,
	MOTOR_ERROR_UNKNOWN_PHASE_VEL					= 0x08000000,
	MOTOR_ERROR_UNKNOWN_TORQUE						= 0x10000000,
	MOTOR_ERROR_UNKNOWN_CURRENT_COMMAND				= 0x20000000,
	MOTOR_ERROR_UNKNOWN_CURRENT_MEASUREMENT			= 0x40000000
	//MOTOR_ERROR_UNKNOWN_VBUS_VOLTAGE				= 0x80000000,
	//MOTOR_ERROR_UNKNOWN_VOLTAGE_COMMAND			= 0x100000000,
	//MOTOR_ERROR_UNKNOWN_GAINS						= 0x200000000,
	//MOTOR_ERROR_CONTROLLER_INITIALIZING			= 0x400000000,
	//MOTOR_ERROR_UNBALANCED_PHASES					= 0x800000000
);

static std::map<std::string, std::string> MotorErrorDesc = {
	{ "MOTOR_ERROR_CONTROL_DEADLINE_MISSED", "Is a result of other errors" }
};





BETTER_ENUM(EncoderError, int32_t,
	ENCODER_ERROR_NONE = 0x0,
	ENCODER_ERROR_UNSTABLE_GAIN = 0x1,
	ENCODER_ERROR_CPR_POLEPAIRS_MISMATCH = 0x2,
	ENCODER_ERROR_NO_RESPONSE = 0x4,
	ENCODER_ERROR_UNSUPPORTED_ENCODER_MODE = 0x8,
	ENCODER_ERROR_ILLEGAL_HALL_STATE = 0x10,
	ENCODER_ERROR_INDEX_NOT_FOUND_YET = 0x20,
	ENCODER_ERROR_ABS_SPI_TIMEOUT = 0x40,
	ENCODER_ERROR_ABS_SPI_COM_FAIL = 0x80,
	ENCODER_ERROR_ABS_SPI_NOT_READY = 0x100,
	ENCODER_ERROR_HALL_NOT_CALIBRATED_YET = 0x200
);

static std::map<std::string, std::string> EncoderErrorDesc = {
	{ "", "" }
};





BETTER_ENUM(ControllerError, int32_t,
	CONTROLLER_ERROR_NONE						= 0x00000000,
	CONTROLLER_ERROR_OVERSPEED					= 0x00000001,
	CONTROLLER_ERROR_INVALID_INPUT_MODE			= 0x00000002,
	CONTROLLER_ERROR_UNSTABLE_GAIN				= 0x00000004,
	CONTROLLER_ERROR_INVALID_MIRROR_AXIS		= 0x00000008,
	CONTROLLER_ERROR_INVALID_LOAD_ENCODER		= 0x00000010,
	CONTROLLER_ERROR_INVALID_ESTIMATE			= 0x00000020,
	CONTROLLER_ERROR_INVALID_CIRCULAR_RANGE		= 0x00000040,
	CONTROLLER_ERROR_SPINOUT_DETECTED			= 0x00000080
);

static std::map<std::string, std::string> ControllerErrorDesc = {
	{ "", "" }
};




BETTER_ENUM(AxisRequestedState, int32_t,
	UNDEFINED							= 0x00,
	IDLE								= 0x01,
	STARTUP_SEQUENCE					= 0x02,
	FULL_CALIBRATION_SEQUENCE			= 0x03,
	MOTOR_CALIBRATION					= 0x04,
	SENSORLESS_CONTROL					= 0x05,
	ENCODER_INDEX_SEARCH				= 0x06,
	ENCODER_OFFSET_CALIBRATION			= 0x07,
	CLOSED_LOOP_CONTROL					= 0x08,
	LOCKIN_SPIN							= 0x09,
	ENCODER_DIR_FIND					= 0x0A,
	HOMING								= 0x0B,
	ENCODER_HALL_POLARITY_CALIBRATION	= 0x0C,
	ENCODER_HALL_PHASE_CALIBRATION		= 0x0D
);

BETTER_ENUM(ControllerControlMode, int32_t,
	VOLTAGE_CONTROL = 0x00,
	TORQUE_CONTROL = 0x01,
	VELOCITY_CONTROL = 0x02,
	POSITION_CONTROL = 0x03
);

BETTER_ENUM(ControllerInputMode, int32_t,
	INACTIVE = 0x00,
	PASSTHROUGH = 0x01,
	VEL_RAMP = 0x02,
	POS_FILTER = 0x03,
	MIX_CHANNELS = 0x04,
	TRAP_TRAJ = 0x05,
	TORQUE_RAMP = 0x06,
	MIRROR = 0x07,
	TUNING = 0x08
);

BETTER_ENUM(EncoderMode, int32_t,
	INCREMENTAL = 0x00,
	HALL = 0x01,
	SINCOS = 0x02,
	SPI_ABS_CUI = 0x100,
	SPI_ABS_AMS = 0x101,
	SPI_ABS_AEAT = 0x102,
	SPI_ABS_RLS = 0x103,
	SPI_ABS_MA732 = 0x104
);

BETTER_ENUM(MotorType, int32_t,
	HIGH_CURRENT = 0x00,
	GIMBAL = 0x02,
	ACIM = 0x03
);











#define ASSIGN_ENUM_STRING(string, _enum) else if (ep.identifier == string) { return _enum::_from_integral(value)._to_string(); }
#define ASSIGN_ENUM_STRING_AXIS(string, _enum) ASSIGN_ENUM_STRING("axis0." string, _enum) ASSIGN_ENUM_STRING("axis1." string, _enum)

inline static const std::string EndpointValueToEnumName(const BasicEndpoint& ep, int32_t value, EndpointValueType type) {

	if (type == EndpointValueType::INVALID)
		return "";

	if (false) {}
	ASSIGN_ENUM_STRING_AXIS("requested_state", AxisRequestedState)
	ASSIGN_ENUM_STRING_AXIS("current_state", AxisRequestedState)
	ASSIGN_ENUM_STRING_AXIS("controller.config.control_mode", ControllerControlMode)
	ASSIGN_ENUM_STRING_AXIS("controller.config.input_mode", ControllerInputMode)
	ASSIGN_ENUM_STRING_AXIS("encoder.config.mode", EncoderMode)
	ASSIGN_ENUM_STRING_AXIS("motor.config.motor_type", MotorType)

	return "";
}

#define ASSIGN_ENUM_INDEX(string, _enum) else if (ep.identifier == string) { return (size_t)_enum::_from_index(index); }
#define ASSIGN_ENUM_INDEX_AXIS(string, _enum) ASSIGN_ENUM_INDEX("axis0." string, _enum) ASSIGN_ENUM_INDEX("axis1." string, _enum)

inline static size_t EnumIndexToValue(const BasicEndpoint& ep, size_t index) {
	
	if (false) {}
	ASSIGN_ENUM_INDEX_AXIS("requested_state", AxisRequestedState)
	ASSIGN_ENUM_INDEX_AXIS("current_state", AxisRequestedState)
	ASSIGN_ENUM_INDEX_AXIS("controller.config.control_mode", ControllerControlMode)
	ASSIGN_ENUM_INDEX_AXIS("controller.config.input_mode", ControllerInputMode)
	ASSIGN_ENUM_INDEX_AXIS("encoder.config.mode", EncoderMode)
	ASSIGN_ENUM_INDEX_AXIS("motor.config.motor_type", MotorType)

	return -1;
}

template<typename T>
constexpr static std::vector<std::string> ListEnumValues() {
	std::vector<std::string> vector;
	for (T element : T::_values()) {
		vector.push_back(element._to_string());
	}
	return vector;
}

#define ASSIGN_ENUM_LIST(string, _enum) else if (ep.identifier == string) { return ListEnumValues<_enum>(); }
#define ASSIGN_ENUM_LIST_AXIS(string, _enum) ASSIGN_ENUM_LIST("axis0." string, _enum) ASSIGN_ENUM_LIST("axis1." string, _enum)

inline static const std::vector<std::string> ListEnumValues(const BasicEndpoint& ep) {

	if (false) {}
	ASSIGN_ENUM_LIST_AXIS("requested_state", AxisRequestedState)
	ASSIGN_ENUM_LIST_AXIS("current_state", AxisRequestedState)
	ASSIGN_ENUM_LIST_AXIS("controller.config.control_mode", ControllerControlMode)
	ASSIGN_ENUM_LIST_AXIS("controller.config.input_mode", ControllerInputMode)
	ASSIGN_ENUM_LIST_AXIS("encoder.config.mode", EncoderMode)
	ASSIGN_ENUM_LIST_AXIS("motor.config.motor_type", MotorType)

	return {};
}
